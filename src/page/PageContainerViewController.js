Ext.define('Zan.ui.page.PageContainerViewController', {
    extend: 'Ext.app.ViewController',

    requires: [
        'Zan.ui.model.ZanAppStateModel',
    ],

    init: function() {
        // The previous page that was shown inside the page view controller
        this._lastActivePage = null;

        // Pages that should not be destroyed immediately
        // Collection of Zan.ui.cache.CachedView models
        this._delayedCleanupQueue = new Ext.util.MixedCollection();

        // Track app state in the top-level view
        this.getViewModel().set('zanAppState', Zan.ui.model.ZanAppStateModel.load('zan-app-state-instance'));
    },

    /**
     * Called from the view, this method converts friendly route definitions into Ext-compatible ones that:
     *   - Support query strings with arbitrary parameters, eg. #/some-page?var1=val&var2=otherVal
     *   - Specify a class to dynamically load into the current page view
     */
    setupRoutes: function(routeDefinitions) {
        var extRouteDef = {};

        Ext.Object.each(routeDefinitions, function(url, value) {
            // Add query string support to the URL
            url += '(:{zanQueryString...})';

            extRouteDef[url] = this._buildZanRoutingHandler(value);

            extRouteDef[url].conditions = {
                'zanQueryString': '\\?([0-9a-zA-Z\\?\\&=\\-\\%\\._]+)'
            };
        }, this);

        this.setRoutes(extRouteDef);

        return extRouteDef;
    },

    /**
     * Returns a routing configuration that performs the following:
     *
     *  - 'before' action ensures we can track which page the route should go to
     *  - 'action' maps to a method in this controller to handle the route
     *  - 'name' stores the target class to load
     *
     *  todo: look into this again, is it all necessary?
     */
    _buildZanRoutingHandler: function(targetPageClassName) {
        // todo: make sure page has been require'd

        return {
            before: Ext.bind(function() {
                // This method will receive a variable number of arguments,
                // action will be the last one
                var action = arguments[arguments.length-1];
                this._pendingTargetPage = targetPageClassName;
                action.resume();
            }, this),
            // The scope of this is the routing controller, see BasePageRoutingController
            action: 'onRouteToPendingTargetPage',
            name: targetPageClassName,
        };
    },

    /**
     * This is the main entry point when the URL changes and the system routes to a new page
     *
     * 1. This method builds query string parameters and calls _displayPage()
     * 2. _displayPage() cleans up the currently active page (if any) and then calls _activatePage
     * 3. _activatePage() creates the component, inserts it into the page view container, and updates zanAppState
     *
     * @param params
     */
    onRouteToPendingTargetPage: function(params) {
        var mergedParams = {};

        // Query string will need to be decoded into an object
        if (!Ext.isEmpty(params.zanQueryString)) {
            // Query string will be an array with one element due to regex matching
            var queryString = params.zanQueryString[0];
            mergedParams = Ext.Object.fromQueryString(queryString);
        }

        // Add in the rest of the parameters
        Ext.Object.each(params, function(key, value) {
            // Skip zanQueryString since it's already parsed
            if ('zanQueryString' === key) return true;

            mergedParams[key] = decodeURIComponent(value);
        });

        // The pending target page is set by the 'before' handler
        // This handler is dynamically generated by Zan.ui.Routing.toPage
        console.info("[ROUTING] to %o with %o", this._pendingTargetPage, mergedParams);
        this._displayPage(this._pendingTargetPage, mergedParams);
    },

    _displayPage: function(className, params) {
        // Clean up previous page
        if (this._lastActivePage) {
            if (this._lastActivePage.getDelayCleanup()) {
                this._cacheView(this._lastActivePage, params);
                this._lastActivePage.hide();
            }
            else {
                this.lookup('zanPageContainer').remove(this._lastActivePage);
            }
        }

        this._activatePage(className, params);
    },

    _activatePage: function(className, routeParams) {
        var cacheKey = this._getComponentKey(className, routeParams);
        var cachedView = this._delayedCleanupQueue.get(cacheKey);
        var pageCmp = null;
        var pageContainer = this.lookup('zanPageContainer');

        if (!pageContainer) {
            throw new Error("Page container view " + Ext.getClass(this.getView()) + " must have a 'zanPageContainer' reference assigned to the parent container which holds pages");
        }

        if (cachedView) {
            pageCmp = cachedView.getView();
        }
        else {
            var pageConfig = {
                zanRouteParameters: routeParams,
                flex: 1,
            };

            pageCmp = Ext.create(className, pageConfig);
            //pageCmp.getViewModel().set('zanRouteParams', routeParams);
        }

        // Verify that pageCmp is a valid page
        if (!(pageCmp instanceof Zan.ui.page.BasePage)) {
            throw new Error("Routed page " + className + " must extend Zan.ui.page.BasePage");
        }

        // Cached, just show it
        if (cachedView) {
            pageCmp.show();
        }
        // Not in the cache of delayed pages, add to page container
        else {
            pageContainer.add(pageCmp);
        }

        Ext.getApplication()
            .getMainView()
            .lookupViewModel()
            .get('zanAppState') // Instance of Zan.ui.model.ZanAppStateModel
            .set('activePage', pageCmp);

        this._lastActivePage = pageCmp;
    },

    _cacheView: function(component, params) {
        var cacheKey = this._getComponentKey(Ext.getClassName(component), params);
        var inCache = this._delayedCleanupQueue.get(cacheKey);

        // If it's already cached, nothing to do
        if (inCache) return;

        // Store in cache
        var cached = new Zan.ui.cache.CachedView({
            view: component,
        });

        this._delayedCleanupQueue.add(cacheKey, cached);
    },

    _getComponentKey: function(className, params) {
        return className + '-' + Ext.Object.toQueryString(params, true);
    },
});